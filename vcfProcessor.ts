
import { VcfLine, ConversionStats } from './types';

/**
 * Parses a single line of VCF data.
 * VCF format: CHROM POS ID REF ALT QUAL FILTER INFO FORMAT SAMPLE
 */
export const parseVcfLine = (line: string): VcfLine | null => {
  if (line.startsWith('#') || !line.trim()) return null;
  
  const fields = line.split('\t');
  if (fields.length < 10) return null;

  const [chrom, pos, id, ref, alt, , , , format, sampleData] = fields;
  
  // Find GT (Genotype) index in format
  const formatFields = format.split(':');
  const gtIndex = formatFields.indexOf('GT');
  if (gtIndex === -1) return null;

  const sampleFields = sampleData.split(':');
  const genotype = sampleFields[gtIndex];

  return { chrom, pos, id, ref, alt, genotype };
};

/**
 * Translates VCF genotype string (e.g., 0/1) to nucleotide string (e.g., AG).
 */
export const translateGenotype = (vcfLine: VcfLine): string => {
  const { ref, alt, genotype } = vcfLine;
  const separators = ['/', '|'];
  let separator = '/';
  
  for (const s of separators) {
    if (genotype.includes(s)) {
      separator = s;
      break;
    }
  }

  const alleles = genotype.split(separator);
  const altList = alt.split(',');

  const getAllele = (index: string) => {
    if (index === '0') return ref;
    const altIdx = parseInt(index, 10) - 1;
    if (!isNaN(altIdx) && altList[altIdx]) return altList[altIdx];
    return '-'; // Missing
  };

  const a1 = getAllele(alleles[0]);
  const a2 = getAllele(alleles[1] || alleles[0]); // Handle haploid

  // 23andMe format expects two characters, e.g., "AA" or "AG"
  // For indels, it's more complex, but GEDmatch primarily cares about SNPs
  // We take first char of alleles for simplicity if it's a long string
  return (a1[0] || '-') + (a2[0] || '-');
};

/**
 * Normalizes chromosome names to GEDmatch expected format (1-22, X, Y, MT).
 */
export const normalizeChrom = (chrom: string): string => {
  let c = chrom.toLowerCase().replace('chr', '');
  if (c === 'm') return 'MT';
  return c.toUpperCase();
};

/**
 * Processes the VCF file in chunks to handle large files.
 */
export const processVcf = async (
  file: File,
  onProgress: (progress: number, message: string) => void
): Promise<{ content: string; stats: ConversionStats }> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    let resultText = '# This file is generated by Genotek-to-GEDmatch Converter\n';
    resultText += '# rsid\tchromosome\tposition\tgenotype\n';

    const stats: ConversionStats = {
      totalVariants: 0,
      processedVariants: 0,
      skippedVariants: 0,
    };

    reader.onload = (e) => {
      try {
        const text = e.target?.result as string;
        const lines = text.split(/\r?\n/);
        const totalLines = lines.length;

        lines.forEach((line, index) => {
          if (index % 10000 === 0) {
            onProgress(Math.floor((index / totalLines) * 100), `Processing line ${index.toLocaleString()}...`);
          }

          if (line.startsWith('##')) {
            if (line.includes('reference') || line.includes('build')) {
               if (line.includes('37') || line.includes('hg19')) stats.referenceBuild = 'GRCh37/hg19';
               if (line.includes('38') || line.includes('hg38')) stats.referenceBuild = 'GRCh38/hg38';
            }
            return;
          }

          const parsed = parseVcfLine(line);
          if (parsed) {
            stats.totalVariants++;
            const genotype = translateGenotype(parsed);
            
            // Only include SNPs with valid rsid or position and valid genotype
            if (genotype !== '--' && genotype.length === 2) {
              const chrom = normalizeChrom(parsed.chrom);
              const rsid = parsed.id !== '.' ? parsed.id : `rs_pos_${parsed.pos}`;
              resultText += `${rsid}\t${chrom}\t${parsed.pos}\t${genotype}\n`;
              stats.processedVariants++;
            } else {
              stats.skippedVariants++;
            }
          }
        });

        resolve({ content: resultText, stats });
      } catch (err) {
        reject(err);
      }
    };

    reader.onerror = () => reject(new Error('File reading failed.'));
    reader.readAsText(file);
  });
};
